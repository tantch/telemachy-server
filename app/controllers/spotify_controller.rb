# frozen_string_literal: true

require 'uri'
require 'net/http'
require 'net/https'

class SpotifyController < ApplicationController
  def index

    puts 'init spotify controller'

    user = User.find_by_email(params[:state])
    data = SpotifyHelper.get_spotify_user_premissions(user, params[:code])

    puts 'data'
    puts data

    user.spotify_token = data['access_token']
    user.spotify_refresh_token = data['refresh_token']
    user.save
    redirect_to ENV['CLIENT_URL']
  end

  def play
    puts 'init spotify play'
    codes = params[:musicCode].map { |c| 'spotify:track:' + c }
    puts codes

    SpotifyHelper.play_song(codes, current_user)

    render status: 200
  end

  def spotify_me
    uri = URI.parse('https://api.spotify.com/v1/me/')
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    request = Net::HTTP::Get.new(uri.path)
    request.add_field('Authorization', 'Bearer ' + current_user.spotify_token)
    response = http.request(request)
    JSON.parse(response.body)
  end

  def fetchSavedSongFeatures(codes)
    puts 'fetching saved song features from Spotify'
    tracksFeatures = []
    codes.each do |spotifyId|
      spotifyId.slice!('spotify:track:')
      songfeature = fetchsongfeatures(spotifyId, true)
      break unless songfeature

      tracksFeatures << songfeature
    end
    tracksFeatures
  end

  def add_songs_to_playlist(playlist_id, codes)
    puts 'add songs to spotify playlist'
    body = {
      uris: codes
    }.to_json
    puts body.inspect
    uri = URI.parse('https://api.spotify.com/v1/playlists/' + playlist_id + '/tracks')
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    request = Net::HTTP::Post.new(uri.path)
    puts 'putting songs to spotify playlist'
    request.body = body
    puts body
    request.add_field('Authorization', 'Bearer ' + current_user.spotify_token)
    response = http.request(request)
    puts response.inspect
    puts response.body
  end

  def create_playlist
    puts 'init create spotify playlist'
    spotify_user = spotify_me
    codes = params[:musicCode].map { |c| 'spotify:track:' + c }

    body = {
      name: 'autogeneratedplaylist-' + (0...8).map { rand(65..90).chr }.join,
      public: false

    }.to_json
    uri = URI.parse('https://api.spotify.com/v1/users/' + spotify_user['id'] + '/playlists')
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    request = Net::HTTP::Post.new(uri.path)
    request.body = body
    request.add_field('Authorization', 'Bearer ' + current_user.spotify_token)
    response = http.request(request)
    playlist = JSON.parse(response.body)

    add_songs_to_playlist(playlist['id'], codes)

    render json: playlist
  end

  def load

    album_list = SpotifyHelper.get_user_spotify_library(current_user)
    album_list.each do |a|
      album = Album.find_or_create_by(name: a[:name], user_id: current_user.id)
      a[:songs].each do |s|
        song = Song.create(name: s[:name], album_id: album.id, user_id: current_user.id)
        SongSource.create(source: s[:source][:name], code: s[:source][:code], song_id: song.id)
      end
    end
    
    render status: 200
  end

  def userPlaylists

    render json: SpotifyHelper.get_user_playlists(current_user)

  end

  def battle
    l1 = SpotifyHelper.get_artist_songs(current_user,params[:a1])
    l2 = SpotifyHelper.get_artist_songs(current_user,params[:a2])
    queue = []
    begin
      n1 = rand(l1.length)
      n2 = rand(l2.length)
      s1 = l1[n1]
      s2 = l2[n2]
      queue.push(s1)
      queue.push(s2)
      l1.delete_at(n1)
      l2.delete_at(n2)
    end while queue.length < 100
    render json: SpotifyHelper.play_song(queue, current_user)
  end

end
